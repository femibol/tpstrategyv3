<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TP Strategy Pro v4.0 - PWA Edition</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVFAgU3RyYXRlZ3kgUHJvIHY0LjAiLCJzaG9ydF9uYW1lIjoiU3RvY2tBbmFseXplciIsImRlc2NyaXB0aW9uIjoiTUwtRW5oYW5jZWQgU3RvY2sgQW5hbHlzaXMgVG9vbCIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMGQxMTE3IiwidGhlbWVfY29sb3IiOiIjMjM4NjM2IiwiaWNvbnMiOlt7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qUXdJaUJvWldsbmFIUTlJakkwTUNJZ2RtbGxkMEp2ZUQwaU1DQXdJakkwTUNBeU5EQWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEpsWTNRZ2VEMGlOREFpSUhrOUlqUXdJaUIzYVdSMGFEMGlNVFl3SWlCb1pXbG5hSFE5SWpFMk1DSWdabWxzYkQwaUl6SXpPRFkwTmlJdlBqeDBaWGgwSUhnOUlqRXlNQ0lnZVQwaU1USTBJaUJtYVd4c1BTSWpabVF3YmpkaVl5SWdabTl1ZEMxbVlXMXBiSGs5SW0xdmJtOXpjR0ZqWlNJZ1ptOXVkQzF6YVhwbFBTSXpNQ0lnZG1Gc2FXZHVMV0poYzJWc2FXNWxQU0p0YVdSa2JHVWlQa2xCTzBBOEwzUmxlSFErUEM5emRtYytJaUJ6YVhwbGN6MGlNall6ZUdNek9ESWlJSFI1Y0dVOUlrbHRZV2RsSWl3aWMzSmpJam9pWkdGMFlUcHBiV0ZuWlM5emRtY3JlRzFzTzJKaGMyVTJOQ3dpUUZCRWVqOW5lR0puU3VncVlpZ3diV05oY0VwN1VHSkVUM0pGWmlOZSIsInNpemVzIjoiMjQweDI0MCIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn1dfQ==">
    
    <!-- Meta tags for mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="StockAnalyzer">
    <meta name="theme-color" content="#238636">
    
    <!-- Chart.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #0d1117;
            color: #f0f6fc;
            margin: 0;
            padding: 0;
        }

        .header {
            background: linear-gradient(135deg, #1f2937, #374151);
            border-bottom: 1px solid #30363d;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-indicators {
            display: flex;
            gap: 0.5rem;
            font-size: 0.8rem;
        }

        .status-online { color: #238636; }
        .status-offline { color: #da3633; }
        .status-loading { color: #ffd700; }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
        }

        .upload-zone {
            border: 2px dashed #30363d;
            border-radius: 8px;
            padding: 2rem 1rem;
            text-align: center;
            cursor: pointer;
            margin: 1rem 0;
            background: #161b22;
            transition: all 0.3s;
        }

        .upload-zone:hover {
            border-color: #58a6ff;
            background: rgba(88, 166, 255, 0.05);
        }

        .upload-zone.dragover {
            border-color: #238636;
            background: rgba(35, 134, 54, 0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .stat-card {
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 0.8rem;
            text-align: center;
        }

        .stat-number {
            font-size: 1.2rem;
            font-weight: bold;
            color: #58a6ff;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #8b949e;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .chart-container {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 1rem;
            position: relative;
            height: 300px;
        }

        .chart-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #f0f6fc;
        }

        .real-time-panel {
            background: #161b22;
            border: 1px solid #238636;
            border-radius: 8px;
            margin: 1rem 0;
            padding: 1rem;
        }

        .real-time-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .price-card {
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 0.8rem;
            text-align: center;
        }

        .price-symbol {
            font-weight: 600;
            color: #58a6ff;
            font-size: 0.9rem;
        }

        .price-current {
            font-size: 1.1rem;
            font-weight: bold;
            margin: 0.2rem 0;
        }

        .price-change {
            font-size: 0.8rem;
        }

        .filters {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .filters select, .filters input {
            min-width: 120px;
            font-size: 0.8rem;
        }

        .btn {
            background: #238636;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 0.4rem 0.8rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .btn:hover {
            background: #2ea043;
        }

        .btn-secondary {
            background: #21262d;
            border: 1px solid #30363d;
        }

        .btn-secondary:hover {
            background: #30363d;
        }

        .btn-api {
            background: #1f6feb;
            border: 1px solid #1f6feb;
        }

        .btn-api:hover {
            background: #1a56db;
        }

        .btn-danger {
            background: #da3633;
            border: 1px solid #da3633;
        }

        .btn-danger:hover {
            background: #f85149;
        }

        .btn-ml {
            background: #a855f7;
            border: 1px solid #a855f7;
        }

        .btn-ml:hover {
            background: #9333ea;
        }

        select, input {
            background: #0d1117;
            color: #f0f6fc;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 0.4rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.75rem;
        }

        th, td {
            text-align: left;
            padding: 0.3rem;
            border-bottom: 1px solid #30363d;
            white-space: nowrap;
        }

        th {
            background: #161b22;
            font-weight: 600;
            position: sticky;
            top: 0;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            padding: 0.5rem 0.3rem;
        }

        th:hover {
            background: #21262d;
        }
        
        /* Non-sortable columns */
        th:nth-child(3), th:last-child {
            cursor: default;
        }
        
        th:nth-child(3):hover, th:last-child:hover {
            background: #161b22;
        }

        tr:hover {
            background: #161b22;
        }

        /* Responsive table wrapper */
        .table-wrapper {
            overflow-x: auto;
            overflow-y: visible;
            position: relative;
            max-height: 600px;
            border: 1px solid #30363d;
            border-radius: 8px;
        }

        .positive { color: #238636; }
        .negative { color: #da3633; }
        .neutral { color: #8b949e; }

        .signal-badge {
            padding: 0.15rem 0.3rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.65rem;
            white-space: nowrap;
        }

        .momentum-buy { background: #238636; color: white; }
        .pullback-buy { background: #1f6feb; color: white; }
        .momentum-forming { background: #ffd700; color: black; }
        .volume-surge { background: #fb8500; color: white; }
        .consolidating { background: #a855f7; color: white; }
        .uptrend-no-setup { background: #8b949e; color: white; }
        .no-setup { background: #30363d; color: #8b949e; }

        .trade-btn {
            padding: 0.15rem 0.3rem;
            font-size: 0.65rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin: 0 0.1rem;
        }

        .buy-btn { background: #238636; color: white; }
        .sell-btn { background: #da3633; color: white; }

        .info-box {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        #resultsSection {
            display: none;
        }

        .file-list {
            margin: 1rem 0;
            padding: 1rem;
            background: #161b22;
            border-radius: 8px;
            border: 1px solid #30363d;
        }

        code {
            background: #0d1117;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }

        .strength-strong { color: #238636; font-weight: bold; }
        .strength-bullish { color: #2ea043; }
        .strength-neutral { color: #8b949e; }
        .strength-bearish { color: #f85149; }
        .strength-weak { color: #da3633; font-weight: bold; }

        .risk-low { color: #238636; }
        .risk-medium { color: #ffd700; }
        .risk-high { color: #f85149; }
        .risk-very-high { color: #da3633; font-weight: bold; }

        .trend-up { color: #238636; }
        .trend-down { color: #da3633; }
        .trend-sideways { color: #8b949e; }

        /* History Panel Styles */
        .history-panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            margin: 1rem 0;
            padding: 1rem;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border-bottom: 1px solid #30363d;
            cursor: pointer;
        }

        .history-item:hover {
            background: #21262d;
        }

        .history-item.active {
            background: rgba(88, 166, 255, 0.1);
            border-left: 3px solid #58a6ff;
        }

        .history-date {
            font-weight: 600;
            color: #f0f6fc;
        }

        .history-count {
            color: #8b949e;
            font-size: 0.875rem;
        }

        .history-actions {
            display: flex;
            gap: 0.5rem;
        }

        .comparison-panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            margin: 1rem 0;
            padding: 1rem;
            display: none;
        }

        .comparison-selectors {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #30363d;
            overflow-x: auto;
        }

        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: #8b949e;
            white-space: nowrap;
        }

        .tab.active {
            color: #f0f6fc;
            border-bottom-color: #58a6ff;
        }

        .tab:hover {
            color: #f0f6fc;
        }

        /* ML Analytics Styles */
        .ml-panel {
            background: #161b22;
            border: 1px solid #a855f7;
            border-radius: 8px;
            margin: 1rem 0;
            padding: 1rem;
        }

        .ml-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .performance-indicator {
            display: inline-block;
            padding: 0.15rem 0.3rem;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: bold;
        }

        .perf-strong-win { background: #238636; color: white; }
        .perf-weak-win { background: #2ea043; color: white; }
        .perf-neutral { background: #8b949e; color: white; }
        .perf-weak-loss { background: #f85149; color: white; }
        .perf-strong-loss { background: #da3633; color: white; }

        .signal-transition {
            font-size: 0.65rem;
            color: #8b949e;
        }

        .days-since {
            font-size: 0.65rem;
            color: #ffd700;
        }

        /* Signal History Mini Chart */
        .signal-history {
            font-size: 0.65rem;
            color: #8b949e;
        }

        /* PWA Install button */
        .install-prompt {
            background: #238636;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.8rem;
            margin-left: 0.5rem;
            display: none;
        }

        .install-prompt:hover {
            background: #2ea043;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }
            
            .logo {
                font-size: 1rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                height: 250px;
            }
            
            .filters {
                gap: 0.3rem;
            }
            
            .filters select, .filters input {
                min-width: 100px;
                font-size: 0.75rem;
            }
            
            .btn {
                padding: 0.3rem 0.6rem;
                font-size: 0.75rem;
            }
            
            table {
                font-size: 0.7rem;
            }
            
            th, td {
                padding: 0.2rem;
            }
        }

        /* Offline indicator */
        .offline-banner {
            background: #da3633;
            color: white;
            text-align: center;
            padding: 0.5rem;
            display: none;
        }

        /* Loading states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #30363d;
            border-radius: 50%;
            border-top-color: #58a6ff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="offline-banner" id="offlineBanner">
        üì± You're offline. Some features may be limited.
    </div>

    <div class="header">
        <div class="logo">
            <span>üöÄ</span>
            <span>TP Strategy Pro v4.0 - PWA Edition</span>
        </div>
        <div class="status-indicators">
            <span id="apiStatus" class="status-offline">üì° API: Offline</span>
            <span id="dataStatus" class="status-offline">üíæ Data: Ready</span>
            <button class="install-prompt" id="installBtn">üì± Install App</button>
        </div>
    </div>

    <div class="container">
        <!-- Tabs for different views -->
        <div class="tabs">
            <div class="tab active" onclick="showTab('analysis')">üìä Analysis</div>
            <div class="tab" onclick="showTab('realtime')">üì° Real-time</div>
            <div class="tab" onclick="showTab('charts')">üìà Charts</div>
            <div class="tab" onclick="showTab('history')">üóÑÔ∏è History</div>
            <div class="tab" onclick="showTab('ml')">ü§ñ ML Analytics</div>
            <div class="tab" onclick="showTab('comparison')">‚öñÔ∏è Compare</div>
        </div>

        <!-- Analysis Tab -->
        <div id="analysisTab" class="tab-content">
            <div class="info-box">
                <strong>üöÄ TP Strategy Pro v4.0 - PWA Edition Features:</strong>
                <div style="margin-top: 0.5rem; font-size: 0.875rem;">
                    <strong>New v4.0 Features:</strong>
                    <ul style="margin: 0.5rem 0;">
                        <li><strong>üì± Progressive Web App</strong> - Install as mobile/desktop app, works offline</li>
                        <li><strong>üì° Real-time Data</strong> - Live prices via Alpha Vantage API</li>
                        <li><strong>üìä Advanced Charts</strong> - Interactive visualizations with Chart.js</li>
                        <li><strong>üîî Smart Notifications</strong> - Alerts for signal changes</li>
                        <li><strong>‚ö° Enhanced Performance</strong> - Optimized for large datasets</li>
                        <li><strong>üì± Mobile Optimized</strong> - Perfect touch interface</li>
                    </ul>
                    <strong>‚ú® Install as an app and get push notifications!</strong>
                </div>
            </div>

            <div class="upload-zone" id="uploadZone">
                <input type="file" id="csvFile" style="display: none;" accept=".csv" multiple />
                <div style="margin-bottom: 1rem;">
                    <span style="font-size: 1.5rem;">üöÄ</span>
                </div>
                <p style="font-size: 1rem; margin: 0;">Drop CSV files here or click to browse</p>
                <p style="color: #8b949e; margin-top: 0.5rem;">PWA Enhanced ‚Ä¢ Real-time Data ‚Ä¢ Advanced Charts</p>
                <p style="color: #fb8500; font-size: 0.75rem; margin-top: 0.5rem;">‚ö†Ô∏è Company names with commas must be in quotes</p>
            </div>

            <div id="fileList" class="file-list" style="display: none;"></div>

            <div id="resultsSection">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="totalStocks">0</div>
                        <div class="stat-label">Total Stocks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" style="color: #238636;" id="buySignals">0</div>
                        <div class="stat-label">Buy Signals</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" style="color: #58a6ff;" id="strongStocks">0</div>
                        <div class="stat-label">Strong Stocks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" style="color: #ffd700;" id="highGrade">0</div>
                        <div class="stat-label">A-B Grades</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" style="color: #a855f7;" id="historyCount">0</div>
                        <div class="stat-label">Stored Uploads</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" style="color: #2ea043;" id="trackedSymbols">0</div>
                        <div class="stat-label">Tracked Symbols</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" style="color: #fb8500;" id="signalChanges">0</div>
                        <div class="stat-label">Signal Changes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" style="color: #1f6feb;" id="realTimeSymbols">0</div>
                        <div class="stat-label">Real-time Tracked</div>
                    </div>
                </div>

                <div class="filters">
                    <input type="text" id="searchBox" placeholder="Search symbols..." />
                    <select id="signalFilter">
                        <option value="">All Signals</option>
                        <option value="MOMENTUM BUY">üü¢ Momentum Buy</option>
                        <option value="PULLBACK BUY">üîµ Pullback Buy</option>
                        <option value="MOMENTUM FORMING">üü° Momentum Forming</option>
                        <option value="VOLUME SURGE">üü† Volume Surge</option>
                        <option value="CONSOLIDATING">üü£ Consolidating</option>
                        <option value="UPTREND - NO SETUP">‚ö™ Uptrend - No Setup</option>
                        <option value="NO SETUP">‚ö´ No Setup</option>
                    </select>
                    <select id="strengthFilter">
                        <option value="">All Strengths</option>
                        <option value="Strong">Strong</option>
                        <option value="Bullish">Bullish</option>
                        <option value="Neutral">Neutral</option>
                        <option value="Bearish">Bearish</option>
                        <option value="Weak">Weak</option>
                    </select>
                    <select id="performanceFilter">
                        <option value="">All Performance</option>
                        <option value="strong-win">Strong Winners (>5%)</option>
                        <option value="weak-win">Weak Winners (0-5%)</option>
                        <option value="neutral">Neutral (-2% to 2%)</option>
                        <option value="weak-loss">Weak Losers (-5% to 0%)</option>
                        <option value="strong-loss">Strong Losers (<-5%)</option>
                    </select>
                    <button class="btn" onclick="applyFilters()">Apply</button>
                    <button class="btn btn-secondary" onclick="clearFilters()">Clear</button>
                    <button class="btn btn-api" onclick="RealTimeAPI.refreshAllPrices()">üîÑ Refresh Prices</button>
                    <button class="btn btn-ml" onclick="MLAnalytics.exportMLDataset()">ü§ñ Export ML</button>
                </div>

                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th onclick="sortTable('rank')">Rank ‚Üï</th>
                                <th onclick="sortTable('symbol')">Symbol ‚Üï</th>
                                <th>Charts</th>
                                <th onclick="sortTable('signal')">Signal ‚Üï</th>
                                <th onclick="sortTable('realTimePrice')">Live Price ‚Üï</th>
                                <th onclick="sortTable('realTimeChange')">Live Change ‚Üï</th>
                                <th onclick="sortTable('lastSignal')">Last Signal ‚Üï</th>
                                <th onclick="sortTable('performanceSinceSignal')">Performance ‚Üï</th>
                                <th onclick="sortTable('daysSinceSignal')">Days ‚Üï</th>
                                <th onclick="sortTable('strength')">Strength ‚Üï</th>
                                <th onclick="sortTable('grade')">Grade ‚Üï</th>
                                <th onclick="sortTable('price')">CSV Price ‚Üï</th>
                                <th onclick="sortTable('change')">CSV Change ‚Üï</th>
                                <th onclick="sortTable('volume')">Volume ‚Üï</th>
                                <th onclick="sortTable('score')">Score ‚Üï</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="stockTable"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Real-time Tab -->
        <div id="realtimeTab" class="tab-content" style="display: none;">
            <div class="real-time-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3>üì° Real-time Market Data</h3>
                    <div>
                        <button class="btn btn-api" onclick="RealTimeAPI.addSymbolToTracking()">‚ûï Add Symbol</button>
                        <button class="btn btn-secondary" onclick="RealTimeAPI.refreshAllPrices()">üîÑ Refresh All</button>
                        <button class="btn btn-secondary" onclick="RealTimeAPI.toggleAutoRefresh()">‚è±Ô∏è Auto Refresh</button>
                    </div>
                </div>
                
                <div class="real-time-grid" id="realTimeGrid">
                    <!-- Real-time price cards will be populated here -->
                </div>
            </div>
        </div>

        <!-- Charts Tab -->
        <div id="chartsTab" class="tab-content" style="display: none;">
            <div style="margin-bottom: 1rem;">
                <h3>üìà Interactive Charts & Analytics</h3>
                <div style="display: flex; gap: 0.5rem; margin: 1rem 0;">
                    <button class="btn btn-secondary" onclick="ChartsAPI.updateAllCharts()">üîÑ Update Charts</button>
                    <button class="btn btn-secondary" onclick="ChartsAPI.exportCharts()">üíæ Export Charts</button>
                </div>
            </div>
            
            <div class="charts-grid">
                <div class="chart-container">
                    <div class="chart-title">Signal Distribution</div>
                    <canvas id="signalChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Performance by Signal Type</div>
                    <canvas id="performanceChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Risk vs Return Scatter</div>
                    <canvas id="riskReturnChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Sector Allocation</div>
                    <canvas id="sectorChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Grade Distribution</div>
                    <canvas id="gradeChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Volume vs Price Change</div>
                    <canvas id="volumePriceChart"></canvas>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div id="historyTab" class="tab-content" style="display: none;">
            <div class="history-panel">
                <div class="history-header">
                    <h3>üìà Historical Uploads</h3>
                    <div class="history-actions">
                        <button class="btn btn-ml" onclick="MLAnalytics.exportSignalHistory()">üß† Export Signal History</button>
                        <button class="btn btn-secondary" onclick="StorageAPI.exportAll()">üì§ Export All</button>
                        <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">üì• Import</button>
                        <input type="file" id="importFile" style="display: none;" accept=".json" onchange="StorageAPI.importData(event)">
                        <button class="btn btn-danger" onclick="StorageAPI.clearAll()">üóëÔ∏è Clear All</button>
                    </div>
                </div>
                <div id="historyList" class="history-list">
                    <!-- History items will be populated here -->
                </div>
            </div>
        </div>

        <!-- ML Analytics Tab -->
        <div id="mlTab" class="tab-content" style="display: none;">
            <div class="ml-panel">
                <h3>ü§ñ Machine Learning Analytics</h3>
                
                <div class="ml-stats">
                    <div class="stat-card">
                        <div class="stat-number" id="mlTotalSignals">0</div>
                        <div class="stat-label">Total Signals Tracked</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="mlWinRate">0%</div>
                        <div class="stat-label">Overall Win Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="mlAvgReturn">0%</div>
                        <div class="stat-label">Avg Return per Signal</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="mlBestSignal">-</div>
                        <div class="stat-label">Best Performing Signal</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="mlDataPoints">0</div>
                        <div class="stat-label">ML Training Points</div>
                    </div>
                </div>

                <div style="display: flex; gap: 0.5rem; margin: 1rem 0; flex-wrap: wrap;">
                    <button class="btn btn-ml" onclick="MLAnalytics.generateSignalReport()">üìä Signal Report</button>
                    <button class="btn btn-ml" onclick="MLAnalytics.analyzeSignalTransitions()">üîÑ Transitions</button>
                    <button class="btn btn-ml" onclick="MLAnalytics.exportMLDataset()">üíæ Export ML Data</button>
                    <button class="btn btn-ml" onclick="MLAnalytics.exportBacktestData()">üìà Export Backtest</button>
                </div>

                <div id="mlResults"></div>
            </div>
        </div>

        <!-- Comparison Tab -->
        <div id="comparisonTab" class="tab-content" style="display: none;">
            <div class="comparison-panel" style="display: block;">
                <h3>‚öñÔ∏è Compare Uploads</h3>
                <div class="comparison-selectors">
                    <div>
                        <label>First Upload:</label>
                        <select id="compareSelect1">
                            <option value="">Select upload...</option>
                        </select>
                    </div>
                    <div>
                        <label>Second Upload:</label>
                        <select id="compareSelect2">
                            <option value="">Select upload...</option>
                        </select>
                    </div>
                    <button class="btn" onclick="ComparisonAPI.compare()">Compare</button>
                    <button class="btn btn-ml" onclick="ComparisonAPI.compareSignalEvolution()">üß† Signal Evolution</button>
                </div>
                <div id="comparisonResults"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let allStocks = [];
        let currentData = [];
        let csvHeaders = [];
        let sortColumn = 'rank';
        let sortDirection = 'asc';
        let currentUploadId = null;
        let charts = {};
        let autoRefreshInterval = null;

        // Alpha Vantage API configuration
        const API_CONFIG = {
            key: 'SGRM0AOJDG9N9OKI',
            baseUrl: 'https://www.alphavantage.co/query',
            rateLimit: 5, // calls per minute for free tier
            lastCall: 0,
            queue: []
        };

        // PWA functionality
        let deferredPrompt;
        let isAppInstalled = false;

        // Service Worker registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register(
                'data:text/javascript;base64,' + btoa(`
                    const CACHE_NAME = 'stock-analyzer-v4';
                    const urlsToCache = [
                        '/',
                        'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js'
                    ];

                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => cache.addAll(urlsToCache))
                        );
                    });

                    self.addEventListener('fetch', event => {
                        if (event.request.url.includes('alphavantage.co')) {
                            // Don't cache API requests
                            return;
                        }
                        
                        event.respondWith(
                            caches.match(event.request)
                                .then(response => {
                                    if (response) {
                                        return response;
                                    }
                                    return fetch(event.request);
                                })
                        );
                    });
                `)
            ).then(() => {
                console.log('‚úÖ Service Worker registered');
            }).catch(err => {
                console.log('‚ùå Service Worker registration failed:', err);
            });
        }

        // PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('installBtn').style.display = 'inline-block';
        });

        document.getElementById('installBtn').addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') {
                    console.log('‚úÖ PWA installed');
                    showNotification('App installed successfully!', 'success');
                }
                deferredPrompt = null;
                document.getElementById('installBtn').style.display = 'none';
            }
        });

        // Check if app is installed
        window.addEventListener('appinstalled', () => {
            isAppInstalled = true;
            document.getElementById('installBtn').style.display = 'none';
            showNotification('Welcome to TP Strategy Pro PWA!', 'success');
        });

        // Online/offline detection
        window.addEventListener('online', () => {
            document.getElementById('offlineBanner').style.display = 'none';
            document.getElementById('apiStatus').className = 'status-online';
            document.getElementById('apiStatus').textContent = 'üì° API: Online';
        });

        window.addEventListener('offline', () => {
            document.getElementById('offlineBanner').style.display = 'block';
            document.getElementById('apiStatus').className = 'status-offline';
            document.getElementById('apiStatus').textContent = 'üì° API: Offline';
        });

        // Real-time API functionality
        const RealTimeAPI = {
            trackedSymbols: new Set(),
            lastPrices: new Map(),
            
            // Rate limited API call
            async makeAPICall(params) {
                const now = Date.now();
                const timeSinceLastCall = now - API_CONFIG.lastCall;
                const minInterval = 60000 / API_CONFIG.rateLimit; // 12 seconds for 5 calls/minute
                
                if (timeSinceLastCall < minInterval) {
                    await new Promise(resolve => setTimeout(resolve, minInterval - timeSinceLastCall));
                }
                
                API_CONFIG.lastCall = Date.now();
                
                const url = new URL(API_CONFIG.baseUrl);
                Object.entries(params).forEach(([key, value]) => {
                    url.searchParams.append(key, value);
                });
                url.searchParams.append('apikey', API_CONFIG.key);
                
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data['Error Message']) {
                        throw new Error(data['Error Message']);
                    }
                    
                    if (data['Note'] && data['Note'].includes('call frequency')) {
                        throw new Error('API rate limit exceeded');
                    }
                    
                    return data;
                } catch (error) {
                    console.error('API Error:', error);
                    throw error;
                }
            },
            
            async getQuote(symbol) {
                try {
                    document.getElementById('apiStatus').className = 'status-loading';
                    document.getElementById('apiStatus').textContent = 'üì° API: Loading...';
                    
                    const data = await this.makeAPICall({
                        function: 'GLOBAL_QUOTE',
                        symbol: symbol
                    });
                    
                    const quote = data['Global Quote'];
                    if (!quote) {
                        throw new Error('No quote data found');
                    }
                    
                    const result = {
                        symbol: quote['01. symbol'],
                        price: parseFloat(quote['05. price']),
                        change: parseFloat(quote['09. change']),
                        changePercent: parseFloat(quote['10. change percent'].replace('%', '')),
                        volume: parseInt(quote['06. volume']),
                        timestamp: new Date().toISOString()
                    };
                    
                    this.lastPrices.set(symbol, result);
                    document.getElementById('apiStatus').className = 'status-online';
                    document.getElementById('apiStatus').textContent = 'üì° API: Online';
                    
                    return result;
                } catch (error) {
                    document.getElementById('apiStatus').className = 'status-offline';
                    document.getElementById('apiStatus').textContent = 'üì° API: Error';
                    console.error(`Failed to get quote for ${symbol}:`, error);
                    throw error;
                }
            },
            
            async refreshAllPrices() {
                if (this.trackedSymbols.size === 0) {
                    // Add current stocks to tracking
                    allStocks.slice(0, 10).forEach(stock => {
                        this.trackedSymbols.add(stock.symbol);
                    });
                }
                
                for (const symbol of this.trackedSymbols) {
                    try {
                        await this.getQuote(symbol);
                        await new Promise(resolve => setTimeout(resolve, 1000)); // Brief delay between calls
                    } catch (error) {
                        console.error(`Failed to refresh ${symbol}:`, error);
                    }
                }
                
                this.updateRealTimeDisplay();
                this.updateStockTable();
                document.getElementById('realTimeSymbols').textContent = this.trackedSymbols.size;
            },
            
            addSymbolToTracking() {
                const symbol = prompt('Enter stock symbol to track (e.g., AAPL):');
                if (symbol) {
                    this.trackedSymbols.add(symbol.toUpperCase());
                    this.getQuote(symbol.toUpperCase()).then(() => {
                        this.updateRealTimeDisplay();
                        document.getElementById('realTimeSymbols').textContent = this.trackedSymbols.size;
                    }).catch(error => {
                        alert(`Failed to add ${symbol}: ${error.message}`);
                        this.trackedSymbols.delete(symbol.toUpperCase());
                    });
                }
            },
            
            updateRealTimeDisplay() {
                const grid = document.getElementById('realTimeGrid');
                grid.innerHTML = Array.from(this.lastPrices.entries()).map(([symbol, data]) => `
                    <div class="price-card">
                        <div class="price-symbol">${symbol}</div>
                        <div class="price-current">$${data.price.toFixed(2)}</div>
                        <div class="price-change ${data.change >= 0 ? 'positive' : 'negative'}">
                            ${data.change >= 0 ? '+' : ''}${data.change.toFixed(2)} (${data.changePercent >= 0 ? '+' : ''}${data.changePercent.toFixed(2)}%)
                        </div>
                        <div style="font-size: 0.7rem; color: #8b949e;">
                            Vol: ${formatVolume(data.volume)}
                        </div>
                    </div>
                `).join('');
            },
            
            updateStockTable() {
                // Add real-time data to current stocks
                allStocks.forEach(stock => {
                    const realTimeData = this.lastPrices.get(stock.symbol);
                    if (realTimeData) {
                        stock.realTimePrice = realTimeData.price;
                        stock.realTimeChange = realTimeData.changePercent;
                        stock.realTimeVolume = realTimeData.volume;
                    } else {
                        stock.realTimePrice = null;
                        stock.realTimeChange = null;
                        stock.realTimeVolume = null;
                    }
                });
                
                renderTable(currentData);
            },
            
            toggleAutoRefresh() {
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                    showNotification('Auto-refresh disabled', 'info');
                } else {
                    autoRefreshInterval = setInterval(() => {
                        this.refreshAllPrices();
                    }, 300000); // 5 minutes
                    showNotification('Auto-refresh enabled (5 min intervals)', 'success');
                }
            }
        };

        // Charts API functionality  
        const ChartsAPI = {
            createSignalChart() {
                const ctx = document.getElementById('signalChart').getContext('2d');
                const signalCounts = {};
                allStocks.forEach(stock => {
                    const signal = stock.signal.replace(/üü¢|üîµ|üü°|üü†|üü£|‚ö™|‚ö´/g, '').trim();
                    signalCounts[signal] = (signalCounts[signal] || 0) + 1;
                });
                
                charts.signalChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: Object.keys(signalCounts),
                        datasets: [{
                            data: Object.values(signalCounts),
                            backgroundColor: [
                                '#238636', '#1f6feb', '#ffd700', '#fb8500', 
                                '#a855f7', '#8b949e', '#30363d'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: { color: '#f0f6fc', font: { size: 10 } }
                            }
                        }
                    }
                });
            },
            
            createPerformanceChart() {
                const ctx = document.getElementById('performanceChart').getContext('2d');
                const signalPerformance = {};
                
                allStocks.forEach(stock => {
                    if (stock.performanceSinceSignal !== null) {
                        const signal = stock.signal.replace(/üü¢|üîµ|üü°|üü†|üü£|‚ö™|‚ö´/g, '').trim();
                        if (!signalPerformance[signal]) {
                            signalPerformance[signal] = [];
                        }
                        signalPerformance[signal].push(stock.performanceSinceSignal);
                    }
                });
                
                const avgPerformance = Object.entries(signalPerformance).map(([signal, perfs]) => ({
                    signal,
                    avg: perfs.reduce((sum, p) => sum + p, 0) / perfs.length
                }));
                
                charts.performanceChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: avgPerformance.map(p => p.signal),
                        datasets: [{
                            label: 'Avg Performance %',
                            data: avgPerformance.map(p => p.avg),
                            backgroundColor: avgPerformance.map(p => p.avg >= 0 ? '#238636' : '#da3633')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#f0f6fc' } }
                        },
                        scales: {
                            y: { 
                                ticks: { color: '#f0f6fc' },
                                grid: { color: '#30363d' }
                            },
                            x: { 
                                ticks: { color: '#f0f6fc' },
                                grid: { color: '#30363d' }
                            }
                        }
                    }
                });
            },
            
            createRiskReturnChart() {
                const ctx = document.getElementById('riskReturnChart').getContext('2d');
                const data = allStocks.filter(s => s.performanceSinceSignal !== null).map(stock => ({
                    x: this.getRiskScore(stock.risk),
                    y: stock.performanceSinceSignal,
                    label: stock.symbol
                }));
                
                charts.riskReturnChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Risk vs Return',
                            data: data,
                            backgroundColor: '#58a6ff',
                            borderColor: '#1f6feb'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#f0f6fc' } }
                        },
                        scales: {
                            y: { 
                                title: { display: true, text: 'Performance %', color: '#f0f6fc' },
                                ticks: { color: '#f0f6fc' },
                                grid: { color: '#30363d' }
                            },
                            x: { 
                                title: { display: true, text: 'Risk Score', color: '#f0f6fc' },
                                ticks: { color: '#f0f6fc' },
                                grid: { color: '#30363d' }
                            }
                        }
                    }
                });
            },
            
            createSectorChart() {
                const ctx = document.getElementById('sectorChart').getContext('2d');
                const sectorCounts = {};
                allStocks.forEach(stock => {
                    const sector = stock.sector || 'Unknown';
                    sectorCounts[sector] = (sectorCounts[sector] || 0) + 1;
                });
                
                charts.sectorChart = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: Object.keys(sectorCounts),
                        datasets: [{
                            data: Object.values(sectorCounts),
                            backgroundColor: [
                                '#238636', '#1f6feb', '#ffd700', '#fb8500', 
                                '#a855f7', '#8b949e', '#da3633', '#2ea043'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: { color: '#f0f6fc', font: { size: 10 } }
                            }
                        }
                    }
                });
            },
            
            createGradeChart() {
                const ctx = document.getElementById('gradeChart').getContext('2d');
                const gradeCounts = {};
                allStocks.forEach(stock => {
                    gradeCounts[stock.grade] = (gradeCounts[stock.grade] || 0) + 1;
                });
                
                charts.gradeChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['A', 'B', 'C', 'D', 'E', 'F'],
                        datasets: [{
                            label: 'Number of Stocks',
                            data: ['A', 'B', 'C', 'D', 'E', 'F'].map(grade => gradeCounts[grade] || 0),
                            backgroundColor: ['#238636', '#2ea043', '#ffd700', '#fb8500', '#f85149', '#da3633']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#f0f6fc' } }
                        },
                        scales: {
                            y: { 
                                ticks: { color: '#f0f6fc' },
                                grid: { color: '#30363d' }
                            },
                            x: { 
                                ticks: { color: '#f0f6fc' },
                                grid: { color: '#30363d' }
                            }
                        }
                    }
                });
            },
            
            createVolumePriceChart() {
                const ctx = document.getElementById('volumePriceChart').getContext('2d');
                const data = allStocks.map(stock => ({
                    x: stock.volSurge,
                    y: stock.change,
                    label: stock.symbol
                }));
                
                charts.volumePriceChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Volume Surge vs Price Change',
                            data: data,
                            backgroundColor: data.map(d => d.y >= 0 ? '#238636' : '#da3633'),
                            borderColor: data.map(d => d.y >= 0 ? '#2ea043' : '#f85149')
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#f0f6fc' } }
                        },
                        scales: {
                            y: { 
                                title: { display: true, text: 'Price Change %', color: '#f0f6fc' },
                                ticks: { color: '#f0f6fc' },
                                grid: { color: '#30363d' }
                            },
                            x: { 
                                title: { display: true, text: 'Volume Surge', color: '#f0f6fc' },
                                ticks: { color: '#f0f6fc' },
                                grid: { color: '#30363d' }
                            }
                        }
                    }
                });
            },
            
            updateAllCharts() {
                if (allStocks.length === 0) {
                    showNotification('No data to chart. Upload CSV first.', 'warning');
                    return;
                }
                
                // Destroy existing charts
                Object.values(charts).forEach(chart => {
                    if (chart) chart.destroy();
                });
                
                // Create new charts
                this.createSignalChart();
                this.createPerformanceChart();
                this.createRiskReturnChart();
                this.createSectorChart();
                this.createGradeChart();
                this.createVolumePriceChart();
                
                showNotification('Charts updated successfully!', 'success');
            },
            
            getRiskScore(risk) {
                const riskScores = { 'Low': 1, 'Medium': 2, 'High': 3, 'Very High': 4 };
                return riskScores[risk] || 2;
            },
            
            exportCharts() {
                const chartsData = {
                    exportDate: new Date().toISOString(),
                    charts: Object.keys(charts).map(chartName => ({
                        name: chartName,
                        image: charts[chartName].toBase64Image()
                    }))
                };
                
                const blob = new Blob([JSON.stringify(chartsData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `charts_export_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                showNotification('Charts exported successfully!', 'success');
            }
        };

        // Notification system
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 1rem;
                border-radius: 8px;
                color: white;
                z-index: 1000;
                font-size: 0.875rem;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            
            const colors = {
                success: '#238636',
                error: '#da3633',
                warning: '#fb8500',
                info: '#1f6feb'
            };
            
            notification.style.backgroundColor = colors[type] || colors.info;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
            
            // Add CSS animations if not already added
            if (!document.getElementById('notificationCSS')) {
                const style = document.createElement('style');
                style.id = 'notificationCSS';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        // Enhanced ML Analytics API
        const MLAnalytics = {
            // Track signal history for each symbol
            updateSignalHistory: (stocks, uploadTimestamp) => {
                stocks.forEach(stock => {
                    const historyKey = `signal_history_${stock.symbol}`;
                    let history = JSON.parse(localStorage.getItem(historyKey) || '[]');
                    
                    // Check if this is a new signal or price update
                    const lastEntry = history[history.length - 1];
                    const currentSignal = stock.signal;
                    
                    if (!lastEntry || lastEntry.signal !== currentSignal) {
                        // New signal - calculate performance of previous signal
                        if (lastEntry) {
                            lastEntry.endPrice = stock.price;
                            lastEntry.endDate = uploadTimestamp;
                            lastEntry.performance = ((stock.price - lastEntry.startPrice) / lastEntry.startPrice * 100);
                            lastEntry.duration = Math.floor((new Date(uploadTimestamp) - new Date(lastEntry.startDate)) / (1000 * 60 * 60 * 24));
                        }
                        
                        // Add new signal entry
                        history.push({
                            signal: currentSignal,
                            startDate: uploadTimestamp,
                            startPrice: stock.price,
                            startVolume: stock.volume,
                            startGrade: stock.grade,
                            startStrength: stock.strength,
                            endPrice: null,
                            endDate: null,
                            performance: null,
                            duration: null
                        });
                    } else {
                        // Same signal - update current entry with latest data
                        if (lastEntry) {
                            lastEntry.endPrice = stock.price;
                            lastEntry.endDate = uploadTimestamp;
                            if (lastEntry.startPrice > 0) {
                                lastEntry.performance = ((stock.price - lastEntry.startPrice) / lastEntry.startPrice * 100);
                            }
                            lastEntry.duration = Math.floor((new Date(uploadTimestamp) - new Date(lastEntry.startDate)) / (1000 * 60 * 60 * 24));
                        }
                    }
                    
                    localStorage.setItem(historyKey, JSON.stringify(history));
                });
            },
            
            // Get signal history for a symbol
            getSignalHistory: (symbol) => {
                const historyKey = `signal_history_${symbol}`;
                return JSON.parse(localStorage.getItem(historyKey) || '[]');
            },
            
            // Calculate performance since last signal change
            calculateSignalPerformance: (stock) => {
                const history = MLAnalytics.getSignalHistory(stock.symbol);
                if (history.length === 0) return null;
                
                const lastSignal = history[history.length - 1];
                if (!lastSignal || !lastSignal.startPrice || lastSignal.startPrice === 0) return null;
                
                const performance = ((stock.price - lastSignal.startPrice) / lastSignal.startPrice * 100);
                const daysSince = Math.floor((new Date() - new Date(lastSignal.startDate)) / (1000 * 60 * 60 * 24));
                
                return {
                    performance: performance,
                    daysSince: daysSince,
                    lastSignal: lastSignal.signal,
                    signalStartDate: lastSignal.startDate,
                    signalStartPrice: lastSignal.startPrice
                };
            },
            
            // Generate comprehensive signal performance report
            generateSignalReport: () => {
                const allSymbols = MLAnalytics.getAllTrackedSymbols();
                const signalStats = {};
                let totalSignals = 0;
                let totalCompletedSignals = 0;
                let totalReturn = 0;
                let winningSignals = 0;
                
                allSymbols.forEach(symbol => {
                    const history = MLAnalytics.getSignalHistory(symbol);
                    history.forEach(entry => {
                        totalSignals++;
                        if (entry.performance !== null) {
                            totalCompletedSignals++;
                            const signal = entry.signal;
                            
                            if (!signalStats[signal]) {
                                signalStats[signal] = {
                                    count: 0,
                                    totalReturn: 0,
                                    wins: 0,
                                    losses: 0,
                                    avgDuration: 0,
                                    totalDuration: 0
                                };
                            }
                            
                            signalStats[signal].count++;
                            signalStats[signal].totalReturn += entry.performance;
                            totalReturn += entry.performance;
                            
                            if (entry.performance > 0) {
                                signalStats[signal].wins++;
                                winningSignals++;
                            } else {
                                signalStats[signal].losses++;
                            }
                            
                            if (entry.duration) {
                                signalStats[signal].totalDuration += entry.duration;
                            }
                        }
                    });
                });
                
                // Calculate averages
                Object.keys(signalStats).forEach(signal => {
                    const stats = signalStats[signal];
                    stats.avgReturn = stats.totalReturn / stats.count;
                    stats.winRate = (stats.wins / stats.count) * 100;
                    stats.avgDuration = stats.totalDuration / stats.count;
                });
                
                const overallWinRate = totalCompletedSignals > 0 ? (winningSignals / totalCompletedSignals) * 100 : 0;
                const overallAvgReturn = totalCompletedSignals > 0 ? totalReturn / totalCompletedSignals : 0;
                
                // Update ML stats display
                document.getElementById('mlTotalSignals').textContent = totalSignals;
                document.getElementById('mlWinRate').textContent = overallWinRate.toFixed(1) + '%';
                document.getElementById('mlAvgReturn').textContent = overallAvgReturn.toFixed(2) + '%';
                document.getElementById('mlDataPoints').textContent = totalCompletedSignals;
                
                // Find best performing signal
                let bestSignal = '-';
                let bestReturn = -Infinity;
                Object.keys(signalStats).forEach(signal => {
                    if (signalStats[signal].avgReturn > bestReturn) {
                        bestReturn = signalStats[signal].avgReturn;
                        bestSignal = signal.replace(/üü¢|üîµ|üü°|üü†|üü£|‚ö™|‚ö´/g, '').trim();
                    }
                });
                document.getElementById('mlBestSignal').textContent = bestSignal;
                
                // Display detailed report
                const resultsDiv = document.getElementById('mlResults');
                resultsDiv.innerHTML = `
                    <h4>üìä Signal Performance Analysis</h4>
                    <div class="table-wrapper">
                        <table>
                            <thead>
                                <tr>
                                    <th>Signal Type</th>
                                    <th>Count</th>
                                    <th>Win Rate</th>
                                    <th>Avg Return</th>
                                    <th>Avg Duration (days)</th>
                                    <th>Total Return</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.entries(signalStats)
                                    .sort((a, b) => b[1].avgReturn - a[1].avgReturn)
                                    .map(([signal, stats]) => `
                                        <tr>
                                            <td><span class="signal-badge ${getSignalClass(signal)}">${signal}</span></td>
                                            <td>${stats.count}</td>
                                            <td class="${stats.winRate >= 50 ? 'positive' : 'negative'}">${stats.winRate.toFixed(1)}%</td>
                                            <td class="${stats.avgReturn >= 0 ? 'positive' : 'negative'}">${stats.avgReturn >= 0 ? '+' : ''}${stats.avgReturn.toFixed(2)}%</td>
                                            <td>${stats.avgDuration.toFixed(1)}</td>
                                            <td class="${stats.totalReturn >= 0 ? 'positive' : 'negative'}">${stats.totalReturn >= 0 ? '+' : ''}${stats.totalReturn.toFixed(2)}%</td>
                                        </tr>
                                    `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                
                console.log('üìä Signal Performance Report Generated');
                console.log('Overall Stats:', {
                    totalSignals,
                    totalCompletedSignals,
                    overallWinRate: overallWinRate.toFixed(2) + '%',
                    overallAvgReturn: overallAvgReturn.toFixed(2) + '%'
                });
                console.log('Signal Stats:', signalStats);
                
                return signalStats;
            },
            
            // Analyze signal transitions (how signals change over time)
            analyzeSignalTransitions: () => {
                const allSymbols = MLAnalytics.getAllTrackedSymbols();
                const transitions = {};
                
                allSymbols.forEach(symbol => {
                    const history = MLAnalytics.getSignalHistory(symbol);
                    for (let i = 1; i < history.length; i++) {
                        const fromSignal = history[i-1].signal;
                        const toSignal = history[i].signal;
                        const transitionKey = `${fromSignal} ‚Üí ${toSignal}`;
                        
                        if (!transitions[transitionKey]) {
                            transitions[transitionKey] = {
                                count: 0,
                                totalReturn: 0,
                                avgReturn: 0
                            };
                        }
                        
                        transitions[transitionKey].count++;
                        if (history[i-1].performance !== null) {
                            transitions[transitionKey].totalReturn += history[i-1].performance;
                        }
                    }
                });
                
                // Calculate averages
                Object.keys(transitions).forEach(key => {
                    const trans = transitions[key];
                    trans.avgReturn = trans.totalReturn / trans.count;
                });
                
                const resultsDiv = document.getElementById('mlResults');
                resultsDiv.innerHTML = `
                    <h4>üîÑ Signal Transition Analysis</h4>
                    <div class="table-wrapper">
                        <table>
                            <thead>
                                <tr>
                                    <th>Signal Transition</th>
                                    <th>Frequency</th>
                                    <th>Avg Return of Previous Signal</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.entries(transitions)
                                    .sort((a, b) => b[1].count - a[1].count)
                                    .map(([transition, stats]) => `
                                        <tr>
                                            <td style="font-size: 0.8rem;">${transition}</td>
                                            <td>${stats.count}</td>
                                            <td class="${stats.avgReturn >= 0 ? 'positive' : 'negative'}">${stats.avgReturn >= 0 ? '+' : ''}${stats.avgReturn.toFixed(2)}%</td>
                                        </tr>
                                    `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                
                console.log('üîÑ Signal Transition Analysis:', transitions);
                return transitions;
            },
            
            // Export ML-ready dataset
            exportMLDataset: () => {
                const allSymbols = MLAnalytics.getAllTrackedSymbols();
                const dataset = [];
                
                allSymbols.forEach(symbol => {
                    const history = MLAnalytics.getSignalHistory(symbol);
                    history.forEach(entry => {
                        if (entry.performance !== null) {
                            dataset.push({
                                symbol: symbol,
                                signal: entry.signal,
                                startDate: entry.startDate,
                                endDate: entry.endDate,
                                startPrice: entry.startPrice,
                                endPrice: entry.endPrice,
                                performance: entry.performance,
                                duration: entry.duration,
                                startVolume: entry.startVolume,
                                startGrade: entry.startGrade,
                                startStrength: entry.startStrength,
                                outcome: entry.performance > 0 ? 'WIN' : 'LOSS',
                                performanceCategory: MLAnalytics.categorizePerformance(entry.performance)
                            });
                        }
                    });
                });
                
                const csvContent = MLAnalytics.convertToCSV(dataset);
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ml_training_dataset_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log(`ü§ñ Exported ML dataset with ${dataset.length} training examples`);
                showNotification(`ML dataset exported: ${dataset.length} examples`, 'success');
                return dataset;
            },
            
            // Export backtest-ready data
            exportBacktestData: () => {
                const uploads = StorageAPI.getAllUploads();
                const backtestData = [];
                
                uploads.forEach(upload => {
                    upload.stocks.forEach(stock => {
                        const signalPerf = MLAnalytics.calculateSignalPerformance(stock);
                        backtestData.push({
                            date: upload.timestamp,
                            symbol: stock.symbol,
                            signal: stock.signal,
                            price: stock.price,
                            volume: stock.volume,
                            grade: stock.grade,
                            strength: stock.strength,
                            risk: stock.risk,
                            score: stock.score,
                            change: stock.change,
                            volSurge: stock.volSurge,
                            yearPosition: stock.yearPosition,
                            performanceSinceSignal: signalPerf ? signalPerf.performance : null,
                            daysSinceSignal: signalPerf ? signalPerf.daysSince : null
                        });
                    });
                });
                
                const csvContent = MLAnalytics.convertToCSV(backtestData);
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `backtest_dataset_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log(`üìà Exported backtest dataset with ${backtestData.length} data points`);
                showNotification(`Backtest data exported: ${backtestData.length} points`, 'success');
                return backtestData;
            },
            
            // Export just signal history
            exportSignalHistory: () => {
                const allSymbols = MLAnalytics.getAllTrackedSymbols();
                const signalHistory = {};
                
                allSymbols.forEach(symbol => {
                    signalHistory[symbol] = MLAnalytics.getSignalHistory(symbol);
                });
                
                const blob = new Blob([JSON.stringify(signalHistory, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `signal_history_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log(`üß† Exported signal history for ${allSymbols.length} symbols`);
                showNotification(`Signal history exported: ${allSymbols.length} symbols`, 'success');
                return signalHistory;
            },
            
            // Helper functions
            getAllTrackedSymbols: () => {
                const symbols = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('signal_history_')) {
                        symbols.push(key.replace('signal_history_', ''));
                    }
                }
                return symbols;
            },
            
            categorizePerformance: (performance) => {
                if (performance > 5) return 'STRONG_WIN';
                if (performance > 0) return 'WEAK_WIN';
                if (performance > -2) return 'NEUTRAL';
                if (performance > -5) return 'WEAK_LOSS';
                return 'STRONG_LOSS';
            },
            
            convertToCSV: (data) => {
                if (data.length === 0) return '';
                
                const headers = Object.keys(data[0]);
                const csvRows = [headers.join(',')];
                
                data.forEach(row => {
                    const values = headers.map(header => {
                        const value = row[header];
                        if (typeof value === 'string' && value.includes(',')) {
                            return `"${value}"`;
                        }
                        return value;
                    });
                    csvRows.push(values.join(','));
                });
                
                return csvRows.join('\n');
            }
        };

        // Enhanced Storage API
        const StorageAPI = {
            saveCurrentData: (filename = null) => {
                if (allStocks.length === 0) {
                    showNotification('No data to save. Upload a CSV first.', 'warning');
                    return;
                }
                
                const timestamp = new Date().toISOString();
                const uploadId = `upload_${Date.now()}`;
                const saveData = {
                    id: uploadId,
                    timestamp: timestamp,
                    filename: filename || `Manual Save ${new Date().toLocaleDateString()}`,
                    stocks: allStocks,
                    count: allStocks.length,
                    headers: csvHeaders,
                    stats: {
                        buySignals: allStocks.filter(s => s.signal.includes('MOMENTUM BUY') || s.signal.includes('PULLBACK BUY')).length,
                        strongStocks: allStocks.filter(s => s.strength === 'Strong' || s.strength === 'Bullish').length,
                        highGrades: allStocks.filter(s => s.grade === 'A' || s.grade === 'B').length
                    }
                };
                
                localStorage.setItem(uploadId, JSON.stringify(saveData));
                
                // Update signal history for ML analytics
                MLAnalytics.updateSignalHistory(allStocks, timestamp);
                
                console.log(`üíæ Saved ${allStocks.length} stocks to browser storage`);
                updateHistoryDisplay();
                updateHistoryCount();
                updateMLStats();
                return uploadId;
            },
            
            loadUpload: (uploadId) => {
                const data = localStorage.getItem(uploadId);
                if (!data) {
                    console.error('Upload not found:', uploadId);
                    return null;
                }
                
                const uploadData = JSON.parse(data);
                allStocks = uploadData.stocks;
                csvHeaders = uploadData.headers || [];
                currentUploadId = uploadId;
                currentData = [...allStocks];
                
                // Add ML performance data to current stocks
                allStocks.forEach(stock => {
                    const signalPerf = MLAnalytics.calculateSignalPerformance(stock);
                    if (signalPerf) {
                        stock.performanceSinceSignal = signalPerf.performance;
                        stock.daysSinceSignal = signalPerf.daysSince;
                        stock.lastSignal = signalPerf.lastSignal;
                        stock.signalChange = stock.signal !== signalPerf.lastSignal ? 'CHANGED' : 'SAME';
                    } else {
                        stock.performanceSinceSignal = null;
                        stock.daysSinceSignal = null;
                        stock.lastSignal = 'NEW';
                        stock.signalChange = 'NEW';
                    }
                    
                    // Add signal history summary
                    const history = MLAnalytics.getSignalHistory(stock.symbol);
                    stock.signalHistory = history.length;
                    stock.signalHistoryText = history.slice(-3).map(h => h.signal.split(' ')[1] || h.signal.charAt(0)).join('‚Üí');
                });
                
                document.getElementById('resultsSection').style.display = 'block';
                renderTable(currentData);
                updateStats();
                
                console.log(`üìÇ Loaded ${allStocks.length} stocks from ${uploadData.filename}`);
                showNotification(`Loaded ${allStocks.length} stocks`, 'success');
                return uploadData;
            },
            
            getAllUploads: () => {
                const uploads = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('upload_')) {
                        const data = JSON.parse(localStorage.getItem(key));
                        uploads.push({
                            id: key,
                            ...data
                        });
                    }
                }
                return uploads.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            },
            
            deleteUpload: (uploadId) => {
                if (confirm('Are you sure you want to delete this upload?')) {
                    localStorage.removeItem(uploadId);
                    updateHistoryDisplay();
                    updateHistoryCount();
                    showNotification('Upload deleted', 'info');
                    console.log(`üóëÔ∏è Deleted upload: ${uploadId}`);
                }
            },
            
            exportAll: () => {
                const allUploads = StorageAPI.getAllUploads();
                const allSignalHistory = {};
                const allSymbols = MLAnalytics.getAllTrackedSymbols();
                
                allSymbols.forEach(symbol => {
                    allSignalHistory[symbol] = MLAnalytics.getSignalHistory(symbol);
                });
                
                const exportData = {
                    exportDate: new Date().toISOString(),
                    version: '4.0',
                    uploads: allUploads,
                    signalHistory: allSignalHistory
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `stock_analysis_v4_export_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log(`üì§ Exported ${allUploads.length} uploads and signal history`);
                showNotification(`Exported ${allUploads.length} uploads`, 'success');
            },
            
            importData: (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        
                        if (!importData.uploads || !Array.isArray(importData.uploads)) {
                            showNotification('Invalid import file format', 'error');
                            return;
                        }
                        
                        let imported = 0;
                        importData.uploads.forEach(upload => {
                            if (!localStorage.getItem(upload.id)) {
                                localStorage.setItem(upload.id, JSON.stringify(upload));
                                imported++;
                            }
                        });
                        
                        // Import signal history if available
                        if (importData.signalHistory) {
                            Object.entries(importData.signalHistory).forEach(([symbol, history]) => {
                                const historyKey = `signal_history_${symbol}`;
                                if (!localStorage.getItem(historyKey)) {
                                    localStorage.setItem(historyKey, JSON.stringify(history));
                                }
                            });
                        }
                        
                        updateHistoryDisplay();
                        updateHistoryCount();
                        updateMLStats();
                        showNotification(`Imported ${imported} uploads successfully`, 'success');
                        console.log(`üì• Imported ${imported} new uploads`);
                        
                    } catch (error) {
                        showNotification('Error importing data: ' + error.message, 'error');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
            },
            
            clearAll: () => {
                if (confirm('Are you sure you want to delete ALL historical data? This cannot be undone.')) {
                    const keys = Object.keys(localStorage);
                    const uploadKeys = keys.filter(key => key.startsWith('upload_'));
                    const signalKeys = keys.filter(key => key.startsWith('signal_history_'));
                    
                    uploadKeys.forEach(key => localStorage.removeItem(key));
                    signalKeys.forEach(key => localStorage.removeItem(key));
                    
                    updateHistoryDisplay();
                    updateHistoryCount();
                    updateMLStats();
                    showNotification(`Cleared ${uploadKeys.length} uploads and ${signalKeys.length} signal histories`, 'info');
                    console.log(`üóëÔ∏è Cleared ${uploadKeys.length} uploads and ${signalKeys.length} signal histories`);
                }
            }
        };

        // Enhanced Comparison API
        const ComparisonAPI = {
            compare: () => {
                const upload1Id = document.getElementById('compareSelect1').value;
                const upload2Id = document.getElementById('compareSelect2').value;
                
                if (!upload1Id || !upload2Id) {
                    showNotification('Please select two uploads to compare', 'warning');
                    return;
                }
                
                const upload1 = JSON.parse(localStorage.getItem(upload1Id));
                const upload2 = JSON.parse(localStorage.getItem(upload2Id));
                
                const comparison = ComparisonAPI.generateComparison(upload1, upload2);
                ComparisonAPI.displayComparison(comparison, upload1, upload2);
            },
            
            compareSignalEvolution: () => {
                const upload1Id = document.getElementById('compareSelect1').value;
                const upload2Id = document.getElementById('compareSelect2').value;
                
                if (!upload1Id || !upload2Id) {
                    showNotification('Please select two uploads to compare', 'warning');
                    return;
                }
                
                const upload1 = JSON.parse(localStorage.getItem(upload1Id));
                const upload2 = JSON.parse(localStorage.getItem(upload2Id));
                
                const signalEvolution = ComparisonAPI.analyzeSignalEvolution(upload1, upload2);
                ComparisonAPI.displaySignalEvolution(signalEvolution, upload1, upload2);
            },
            
            generateComparison: (upload1, upload2) => {
                const stocks1 = upload1.stocks;
                const stocks2 = upload2.stocks;
                
                const common = [];
                const onlyIn1 = [];
                const onlyIn2 = [];
                
                const symbols2 = new Set(stocks2.map(s => s.symbol));
                const symbols1 = new Set(stocks1.map(s => s.symbol));
                
                stocks1.forEach(stock1 => {
                    const stock2 = stocks2.find(s => s.symbol === stock1.symbol);
                    if (stock2) {
                        common.push({
                            symbol: stock1.symbol,
                            upload1: stock1,
                            upload2: stock2,
                            priceChange: ((stock2.price - stock1.price) / stock1.price * 100),
                            scoreChange: stock2.score - stock1.score,
                            gradeChange: stock1.grade !== stock2.grade,
                            signalChange: stock1.signal !== stock2.signal
                        });
                    } else {
                        onlyIn1.push(stock1);
                    }
                });
                
                stocks2.forEach(stock2 => {
                    if (!symbols1.has(stock2.symbol)) {
                        onlyIn2.push(stock2);
                    }
                });
                
                return {
                    common,
                    onlyIn1,
                    onlyIn2,
                    stats: {
                        commonCount: common.length,
                        avgPriceChange: common.reduce((sum, s) => sum + s.priceChange, 0) / common.length || 0,
                        avgScoreChange: common.reduce((sum, s) => sum + s.scoreChange, 0) / common.length || 0,
                        signalChanges: common.filter(s => s.signalChange).length
                    }
                };
            },
            
            analyzeSignalEvolution: (upload1, upload2) => {
                const stocks1 = upload1.stocks;
                const stocks2 = upload2.stocks;
                const signalChanges = [];
                
                stocks1.forEach(stock1 => {
                    const stock2 = stocks2.find(s => s.symbol === stock1.symbol);
                    if (stock2 && stock1.signal !== stock2.signal) {
                        signalChanges.push({
                            symbol: stock1.symbol,
                            fromSignal: stock1.signal,
                            toSignal: stock2.signal,
                            priceChange: ((stock2.price - stock1.price) / stock1.price * 100),
                            performance: ((stock2.price - stock1.price) / stock1.price * 100)
                        });
                    }
                });
                
                return signalChanges;
            },
            
            displayComparison: (comparison, upload1, upload2) => {
                const resultsDiv = document.getElementById('comparisonResults');
                resultsDiv.innerHTML = `
                    <div style="margin-top: 2rem;">
                        <h4>üìä Comparison Results</h4>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-number">${comparison.common.length}</div>
                                <div class="stat-label">Common Stocks</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number ${comparison.stats.avgPriceChange >= 0 ? 'positive' : 'negative'}">
                                    ${comparison.stats.avgPriceChange >= 0 ? '+' : ''}${comparison.stats.avgPriceChange.toFixed(2)}%
                                </div>
                                <div class="stat-label">Avg Price Change</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number ${comparison.stats.avgScoreChange >= 0 ? 'positive' : 'negative'}">
                                    ${comparison.stats.avgScoreChange >= 0 ? '+' : ''}${comparison.stats.avgScoreChange.toFixed(2)}
                                </div>
                                <div class="stat-label">Avg Score Change</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${comparison.stats.signalChanges}</div>
                                <div class="stat-label">Signal Changes</div>
                            </div>
                        </div>
                        
                        <h5>üîù Biggest Gainers</h5>
                        <div class="table-wrapper">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Symbol</th>
                                        <th>Price Change</th>
                                        <th>Score Change</th>
                                        <th>Old Signal</th>
                                        <th>New Signal</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${comparison.common
                                        .sort((a, b) => b.priceChange - a.priceChange)
                                        .slice(0, 10)
                                        .map(stock => `
                                            <tr>
                                                <td>${stock.symbol}</td>
                                                <td class="${stock.priceChange >= 0 ? 'positive' : 'negative'}">
                                                    ${stock.priceChange >= 0 ? '+' : ''}${stock.priceChange.toFixed(2)}%
                                                </td>
                                                <td class="${stock.scoreChange >= 0 ? 'positive' : 'negative'}">
                                                    ${stock.scoreChange >= 0 ? '+' : ''}${stock.scoreChange.toFixed(1)}
                                                </td>
                                                <td><span class="signal-badge ${getSignalClass(stock.upload1.signal)}">${stock.upload1.signal}</span></td>
                                                <td><span class="signal-badge ${getSignalClass(stock.upload2.signal)}">${stock.upload2.signal}</span></td>
                                            </tr>
                                        `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            },
            
            displaySignalEvolution: (signalChanges, upload1, upload2) => {
                const resultsDiv = document.getElementById('comparisonResults');
                resultsDiv.innerHTML = `
                    <div style="margin-top: 2rem;">
                        <h4>üß† Signal Evolution Analysis</h4>
                        <p>Found ${signalChanges.length} signal changes between uploads</p>
                        
                        <div class="table-wrapper">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Symbol</th>
                                        <th>Signal Transition</th>
                                        <th>Performance</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${signalChanges
                                        .sort((a, b) => b.performance - a.performance)
                                        .map(change => `
                                            <tr>
                                                <td>${change.symbol}</td>
                                                <td style="font-size: 0.8rem;">
                                                    <span class="signal-badge ${getSignalClass(change.fromSignal)}">${change.fromSignal}</span>
                                                    ‚Üí
                                                    <span class="signal-badge ${getSignalClass(change.toSignal)}">${change.toSignal}</span>
                                                </td>
                                                <td class="${change.performance >= 0 ? 'positive' : 'negative'}">
                                                    ${change.performance >= 0 ? '+' : ''}${change.performance.toFixed(2)}%
                                                </td>
                                            </tr>
                                        `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            }
        };

        // Tab switching
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + 'Tab').style.display = 'block';
            event.target.classList.add('active');
            
            // Update displays if needed
            if (tabName === 'history') {
                updateHistoryDisplay();
            } else if (tabName === 'comparison') {
                updateComparisonSelectors();
            } else if (tabName === 'ml') {
                updateMLStats();
            } else if (tabName === 'charts') {
                ChartsAPI.updateAllCharts();
            } else if (tabName === 'realtime') {
                RealTimeAPI.updateRealTimeDisplay();
            }
        }

        // Update ML stats
        function updateMLStats() {
            const trackedSymbols = MLAnalytics.getAllTrackedSymbols().length;
            document.getElementById('trackedSymbols').textContent = trackedSymbols;
            
            // Count total signal changes
            let totalSignalChanges = 0;
            MLAnalytics.getAllTrackedSymbols().forEach(symbol => {
                const history = MLAnalytics.getSignalHistory(symbol);
                totalSignalChanges += history.length;
            });
            document.getElementById('signalChanges').textContent = totalSignalChanges;
        }

        // Update history display
        function updateHistoryDisplay() {
            const uploads = StorageAPI.getAllUploads();
            const historyList = document.getElementById('historyList');
            
            if (uploads.length === 0) {
                historyList.innerHTML = '<p style="text-align: center; color: #8b949e;">No historical data found. Upload some CSV files to build your history.</p>';
                return;
            }
            
            historyList.innerHTML = uploads.map(upload => `
                <div class="history-item ${currentUploadId === upload.id ? 'active' : ''}" onclick="StorageAPI.loadUpload('${upload.id}')">
                    <div>
                        <div class="history-date">${new Date(upload.timestamp).toLocaleDateString()} ${new Date(upload.timestamp).toLocaleTimeString()}</div>
                        <div class="history-count">${upload.count} stocks - ${upload.filename}</div>
                    </div>
                    <div class="history-actions">
                        <button class="btn btn-secondary" onclick="event.stopPropagation(); StorageAPI.deleteUpload('${upload.id}')" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        // Update comparison selectors
        function updateComparisonSelectors() {
            const uploads = StorageAPI.getAllUploads();
            const select1 = document.getElementById('compareSelect1');
            const select2 = document.getElementById('compareSelect2');
            
            const options = uploads.map(upload => 
                `<option value="${upload.id}">${new Date(upload.timestamp).toLocaleDateString()} - ${upload.filename} (${upload.count} stocks)</option>`
            ).join('');
            
            select1.innerHTML = '<option value="">Select upload...</option>' + options;
            select2.innerHTML = '<option value="">Select upload...</option>' + options;
        }

        // Update history count in stats
        function updateHistoryCount() {
            const uploads = StorageAPI.getAllUploads();
            document.getElementById('historyCount').textContent = uploads.length;
        }

        // Initialize
        function init() {
            setupDragDrop();
            updateHistoryCount();
            updateMLStats();
            
            // Add current stocks to real-time tracking on load
            if (allStocks.length > 0) {
                allStocks.slice(0, 5).forEach(stock => {
                    RealTimeAPI.trackedSymbols.add(stock.symbol);
                });
                document.getElementById('realTimeSymbols').textContent = RealTimeAPI.trackedSymbols.size;
            }
            
            console.log('‚úÖ TP Strategy Pro v4.0 - PWA Edition Ready!');
            console.log('');
            console.log('üöÄ NEW PWA FEATURES:');
            console.log('‚Ä¢ Progressive Web App - install as desktop/mobile app');
            console.log('‚Ä¢ Real-time data via Alpha Vantage API');
            console.log('‚Ä¢ Interactive charts with Chart.js');
            console.log('‚Ä¢ Enhanced mobile optimization');
            console.log('‚Ä¢ Offline functionality with service worker');
            console.log('‚Ä¢ Smart notifications system');
            console.log('');
            console.log('üìÅ Upload your CSV to begin enhanced analysis');
            console.log('üí° Run CSVAPI.help() for all commands');
            console.log('üöÄ Install as PWA for best experience');
            
            showNotification('TP Strategy Pro v4.0 PWA Ready!', 'success');
        }

        function setupDragDrop() {
            const zone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('csvFile');

            zone.addEventListener('click', () => fileInput.click());
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, preventDefaults);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.add('dragover'));
            });

            ['dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.remove('dragover'));
            });

            zone.addEventListener('drop', handleDrop);
            fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        }

        function handleDrop(e) {
            handleFiles(e.dataTransfer.files);
        }

        function parseCSVLine(str) {
            const result = [];
            let startValue = 0;
            let inQuotes = false;
            
            for (let i = 0; i < str.length; i++) {
                if (str[i] === '"') {
                    inQuotes = !inQuotes;
                } else if (str[i] === ',' && !inQuotes) {
                    result.push(str.substring(startValue, i).replace(/^"|"$/g, ''));
                    startValue = i + 1;
                }
            }
            
            result.push(str.substring(startValue).replace(/^"|"$/g, ''));
            return result;
        }

        async function handleFiles(files) {
            const fileList = document.getElementById('fileList');
            fileList.style.display = 'block';
            fileList.innerHTML = '<strong>Processing...</strong>';

            allStocks = [];
            let totalStocksBeforeDedup = 0;
            let filename = files.length === 1 ? files[0].name : `${files.length} files combined`;
            
            for (const file of files) {
                const text = await file.text();
                const stocks = parseCSV(text);
                allStocks.push(...stocks);
                totalStocksBeforeDedup += stocks.length;
            }

            // Remove duplicates by symbol, keeping the most complete data
            const duplicatesRemoved = removeDuplicates();
            
            processStocks();
            
            // Add ML performance data to stocks before displaying
            allStocks.forEach(stock => {
                const signalPerf = MLAnalytics.calculateSignalPerformance(stock);
                if (signalPerf) {
                    stock.performanceSinceSignal = signalPerf.performance;
                    stock.daysSinceSignal = signalPerf.daysSince;
                    stock.lastSignal = signalPerf.lastSignal;
                    stock.signalChange = stock.signal !== signalPerf.lastSignal ? 'CHANGED' : 'SAME';
                } else {
                    stock.performanceSinceSignal = null;
                    stock.daysSinceSignal = null;
                    stock.lastSignal = 'NEW';
                    stock.signalChange = 'NEW';
                }
                
                // Add signal history summary
                const history = MLAnalytics.getSignalHistory(stock.symbol);
                stock.signalHistory = history.length;
                stock.signalHistoryText = history.slice(-3).map(h => h.signal.split(' ')[1] || h.signal.charAt(0)).join('‚Üí');
            });
            
            // Add top stocks to real-time tracking
            allStocks.slice(0, 10).forEach(stock => {
                RealTimeAPI.trackedSymbols.add(stock.symbol);
            });
            
            document.getElementById('resultsSection').style.display = 'block';
            currentData = [...allStocks];
            renderTable(currentData);
            updateStats();

            // Auto-save to storage (this will update signal history)
            const uploadId = StorageAPI.saveCurrentData(filename);
            currentUploadId = uploadId;

            // Updated status message with duplicate info
            let statusMessage = `<strong style="color: #238636;">‚úÖ Loaded ${allStocks.length} stocks from ComboScan CSV</strong>`;
            if (duplicatesRemoved > 0) {
                statusMessage += `<div style="color: #ffd700; margin-top: 0.5rem;">üîÑ Removed ${duplicatesRemoved} duplicate symbols</div>`;
            }
            statusMessage += `<div style="color: #58a6ff; margin-top: 0.5rem;">üíæ Auto-saved to browser storage</div>`;
            statusMessage += `<div style="color: #a855f7; margin-top: 0.5rem;">ü§ñ Signal history updated for ML analytics</div>`;
            statusMessage += `<div style="color: #1f6feb; margin-top: 0.5rem;">üì° Added ${Math.min(10, allStocks.length)} symbols to real-time tracking</div>`;
            fileList.innerHTML = statusMessage;
            
            console.log(`‚úÖ Successfully loaded ${allStocks.length} stocks`);
            if (duplicatesRemoved > 0) {
                console.log(`üîÑ Removed ${duplicatesRemoved} duplicates (${totalStocksBeforeDedup} ‚Üí ${allStocks.length})`);
            }
            console.log(`üíæ Auto-saved as: ${filename}`);
            console.log(`ü§ñ Signal history updated for ML analytics`);
            console.log(`üì° Added symbols to real-time tracking`);
            
            showNotification(`Loaded ${allStocks.length} stocks successfully!`, 'success');
        }

        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const headers = parseCSVLine(lines[0]);
            csvHeaders = headers;
            
            console.log('CSV Headers:', headers);
            
            const stocks = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                const stock = {};
                
                // Map values to column names
                headers.forEach((header, index) => {
                    stock[header] = values[index] || '';
                });
                
                // Extract fields based on YOUR CSV columns with better error handling
                const processedStock = {
                    symbol: stock.symbol || '',
                    price: parseFloat(stock.close_price) || 0,
                    change: parseFloat(stock.change_in_percent) || 0,
                    volume: parseInt(stock.volume) || 0,
                    volSurge: parseFloat(stock.vol_vs_avg) || 1,
                    gradeNumber: parseFloat(stock.grade_number) || 50,
                    sector: stock.sector || '',
                    industry: stock.industry || '',
                    tradingviewSymbol: stock.tradingview_symbol || stock.symbol || '',
                    rank: 0,
                    // Add additional fields for enhanced analysis
                    yearHigh: parseFloat(stock.year_high) || 0,
                    yearLow: parseFloat(stock.year_low) || 0,
                    atr: parseFloat(stock.atr) || 0,
                    adx: parseFloat(stock.adx) || 0
                };
                
                // Skip if critical data is missing
                if (!processedStock.symbol || processedStock.symbol === '') {
                    continue;
                }
                
                // Calculate 52-week position
                if (processedStock.yearHigh > 0 && processedStock.yearLow > 0) {
                    processedStock.yearPosition = Math.round(((processedStock.price - processedStock.yearLow) / (processedStock.yearHigh - processedStock.yearLow)) * 100);
                } else {
                    processedStock.yearPosition = 50; // Default to middle
                }
                
                // Determine grade from grade_number
                let grade = 'C';
                if (processedStock.gradeNumber >= 90) grade = 'A';
                else if (processedStock.gradeNumber >= 80) grade = 'B';
                else if (processedStock.gradeNumber >= 70) grade = 'C';
                else if (processedStock.gradeNumber >= 60) grade = 'D';
                else if (processedStock.gradeNumber >= 50) grade = 'E';
                else grade = 'F';
                
                processedStock.grade = grade;
                
                if (processedStock.symbol && processedStock.price > 0) {
                    stocks.push(processedStock);
                }
            }
            
            return stocks;
        }

        // Remove duplicates by symbol, keeping the most complete/recent data
        function removeDuplicates() {
            const symbolMap = new Map();
            let duplicatesCount = 0;
            
            // Process each stock and keep the best version of each symbol
            allStocks.forEach(stock => {
                const symbol = stock.symbol;
                
                if (symbolMap.has(symbol)) {
                    duplicatesCount++;
                    const existing = symbolMap.get(symbol);
                    
                    // Keep the stock with better data quality (higher score, more complete data)
                    const keepCurrent = shouldKeepCurrentStock(stock, existing);
                    if (keepCurrent) {
                        symbolMap.set(symbol, stock);
                        console.log(`üîÑ Duplicate found: ${symbol} - keeping newer/better data`);
                    }
                } else {
                    symbolMap.set(symbol, stock);
                }
            });
            
            // Replace allStocks with deduplicated array
            allStocks = Array.from(symbolMap.values());
            
            return duplicatesCount;
        }

        // Determine which stock data to keep when duplicates are found
        function shouldKeepCurrentStock(current, existing) {
            // Priority 1: Keep stock with valid price over invalid price
            if (current.price > 0 && existing.price <= 0) return true;
            if (existing.price > 0 && current.price <= 0) return false;
            
            // Priority 2: Keep stock with valid volume over invalid volume
            if (current.volume > 0 && existing.volume <= 0) return true;
            if (existing.volume > 0 && current.volume <= 0) return false;
            
            // Priority 3: Keep stock with better grade data
            if (current.gradeNumber > 0 && existing.gradeNumber <= 0) return true;
            if (existing.gradeNumber > 0 && current.gradeNumber <= 0) return false;
            
            // Priority 4: Keep stock with higher grade number (better fundamentals)
            if (current.gradeNumber > existing.gradeNumber) return true;
            if (existing.gradeNumber > current.gradeNumber) return false;
            
            // Priority 5: Keep stock with more complete sector/industry data
            const currentCompleteness = (current.sector ? 1 : 0) + (current.industry ? 1 : 0);
            const existingCompleteness = (existing.sector ? 1 : 0) + (existing.industry ? 1 : 0);
            if (currentCompleteness > existingCompleteness) return true;
            if (existingCompleteness > currentCompleteness) return false;
            
            // Default: keep existing (first occurrence)
            return false;
        }
        
        // Calculate stock strength based on multiple factors
        function calculateStockStrength(stock) {
            let strengthScore = 0;
            
            // Price momentum
            if (stock.change > 3) strengthScore += 3;
            else if (stock.change > 1) strengthScore += 2;
            else if (stock.change > 0) strengthScore += 1;
            else if (stock.change < -3) strengthScore -= 2;
            else if (stock.change < -1) strengthScore -= 1;
            
            // Volume strength
            if (stock.volSurge > 2) strengthScore += 2;
            else if (stock.volSurge > 1.5) strengthScore += 1;
            else if (stock.volSurge < 0.5) strengthScore -= 1;
            
            // Grade quality
            if (stock.gradeNumber >= 80) strengthScore += 2;
            else if (stock.gradeNumber >= 70) strengthScore += 1;
            else if (stock.gradeNumber < 50) strengthScore -= 1;
            
            // 52-week position
            if (stock.yearPosition > 80) strengthScore += 2;
            else if (stock.yearPosition > 60) strengthScore += 1;
            else if (stock.yearPosition < 20) strengthScore -= 2;
            else if (stock.yearPosition < 40) strengthScore -= 1;
            
            // ADX trend strength
            if (stock.adx > 40) strengthScore += 2;
            else if (stock.adx > 25) strengthScore += 1;
            else if (stock.adx < 20) strengthScore -= 1;
            
            // Determine strength category
            if (strengthScore >= 6) return 'Strong';
            else if (strengthScore >= 3) return 'Bullish';
            else if (strengthScore >= 0) return 'Neutral';
            else if (strengthScore >= -3) return 'Bearish';
            else return 'Weak';
        }
        
        // Determine trend direction
        function determineTrend(stock) {
            if (stock.change > 2 && stock.volSurge > 1.2) return 'Up Strong';
            else if (stock.change > 0) return 'Up';
            else if (stock.change < -2 && stock.volSurge > 1.2) return 'Down Strong';
            else if (stock.change < 0) return 'Down';
            else return 'Sideways';
        }
        
        // Calculate risk level
        function calculateRiskLevel(stock) {
            let riskScore = 0;
            
            // Volatility risk (using ATR if available)
            if (stock.atr > 0 && stock.price > 0) {
                const atrPercent = (stock.atr / stock.price) * 100;
                if (atrPercent > 5) riskScore += 3;
                else if (atrPercent > 3) riskScore += 2;
                else if (atrPercent > 2) riskScore += 1;
            }
            
            // Price level risk
            if (stock.price < 5) riskScore += 2; // Penny stock risk
            else if (stock.price < 10) riskScore += 1;
            
            // Volume risk
            if (stock.volume < 100000) riskScore += 2; // Low liquidity
            else if (stock.volume < 500000) riskScore += 1;
            
            // Grade risk
            if (stock.gradeNumber < 50) riskScore += 2;
            else if (stock.gradeNumber < 60) riskScore += 1;
            
            // Determine risk category
            if (riskScore >= 6) return 'Very High';
            else if (riskScore >= 4) return 'High';
            else if (riskScore >= 2) return 'Medium';
            else return 'Low';
        }

        function processStocks() {
            allStocks.forEach(stock => {
                stock.score = calculateScore(stock);
                stock.signal = generateSignal(stock);
                stock.signalClass = getSignalClass(stock.signal);
                stock.strength = calculateStockStrength(stock);
                stock.trend = determineTrend(stock);
                stock.risk = calculateRiskLevel(stock);
            });

            // Sort by score (best first) - filter out invalid scores
            allStocks = allStocks.filter(s => !isNaN(s.score));
            allStocks.sort((a, b) => b.score - a.score);

            // Assign ranks
            allStocks.forEach((stock, index) => {
                stock.rank = index + 1;
            });
        }

        function calculateScore(stock) {
            // Ensure valid numbers
            const gradeNumber = stock.gradeNumber || 50;
            const volSurge = stock.volSurge || 1;
            const change = stock.change || 0;
            
            const gradeScore = (gradeNumber / 100) * 35;
            const volumeScore = Math.min(volSurge * 5, 25);
            const momentumScore = Math.max(0, change) * 0.8;
            const total = gradeScore + volumeScore + momentumScore;
            
            // Ensure we have a valid score
            const score = Math.round(total * 10) / 10;
            return isNaN(score) ? 0 : score;
        }

        function generateSignal(stock) {
            // Adjusted for ComboScan daily data with fallbacks
            const change = stock.change || 0;
            const volSurge = stock.volSurge || 1;
            const gradeNumber = stock.gradeNumber || 50;
            
            const upDays = change >= 3 ? 3 : change >= 2 ? 2 : change >= 0.5 ? 1 : 0;
            
            // MOMENTUM BUY - strong momentum pattern
            if (upDays >= 2 && volSurge >= 1.2 && change >= 1.0 && gradeNumber >= 70) {
                return 'üü¢ MOMENTUM BUY';
            }
            // PULLBACK BUY - consolidation breakout
            else if (volSurge >= 1.3 && change >= 0.5 && gradeNumber >= 65) {
                return 'üîµ PULLBACK BUY';
            }
            // MOMENTUM FORMING - almost ready
            else if (upDays >= 1 && volSurge >= 1.0 && change >= 0.3 && gradeNumber >= 60) {
                return 'üü° MOMENTUM FORMING';
            }
            // VOLUME SURGE - volume spike detected
            else if (volSurge >= 1.5 && change >= 0.5) {
                return 'üü† VOLUME SURGE';
            }
            // CONSOLIDATING - in consolidation
            else if (change >= -0.5 && change <= 1.5 && gradeNumber >= 50) {
                return 'üü£ CONSOLIDATING';
            }
            // UPTREND NO SETUP - positive but no pattern
            else if (change >= 0) {
                return '‚ö™ UPTREND - NO SETUP';
            }
            // NO SETUP - no bullish patterns
            else {
                return '‚ö´ NO SETUP';
            }
        }

        function getSignalClass(signal) {
            const classMap = {
                'üü¢ MOMENTUM BUY': 'momentum-buy',
                'üîµ PULLBACK BUY': 'pullback-buy',
                'üü° MOMENTUM FORMING': 'momentum-forming',
                'üü† VOLUME SURGE': 'volume-surge',
                'üü£ CONSOLIDATING': 'consolidating',
                '‚ö™ UPTREND - NO SETUP': 'uptrend-no-setup',
                '‚ö´ NO SETUP': 'no-setup'
            };
            return classMap[signal] || 'no-setup';
        }

        function getStrengthClass(strength) {
            const classMap = {
                'Strong': 'strength-strong',
                'Bullish': 'strength-bullish',
                'Neutral': 'strength-neutral',
                'Bearish': 'strength-bearish',
                'Weak': 'strength-weak'
            };
            return classMap[strength] || 'strength-neutral';
        }

        function getRiskClass(risk) {
            const classMap = {
                'Low': 'risk-low',
                'Medium': 'risk-medium',
                'High': 'risk-high',
                'Very High': 'risk-very-high'
            };
            return classMap[risk] || 'risk-medium';
        }

        function getTrendClass(trend) {
            if (trend.includes('Up')) return 'trend-up';
            else if (trend.includes('Down')) return 'trend-down';
            else return 'trend-sideways';
        }

        function getPerformanceClass(performance) {
            if (performance === null || performance === undefined) return 'neutral';
            if (performance > 5) return 'perf-strong-win';
            if (performance > 0) return 'perf-weak-win';
            if (performance > -2) return 'perf-neutral';
            if (performance > -5) return 'perf-weak-loss';
            return 'perf-strong-loss';
        }

        function renderTable(data) {
            const tbody = document.getElementById('stockTable');
            tbody.innerHTML = data.map(stock => `
                <tr>
                    <td>${stock.rank}</td>
                    <td><a href="https://www.tradingview.com/chart/?symbol=${stock.tradingviewSymbol || stock.symbol}" target="_blank" style="color: #58a6ff;">${stock.symbol}</a></td>
                    <td>
                        <a href="https://www.tradingview.com/chart/?symbol=${stock.tradingviewSymbol || stock.symbol}" target="_blank" style="margin-right: 0.5rem;">üìä</a>
